# coding: utf-8

"""
    DDF USDM API

    A simple TransCelerate Digital Data Flow (DDF) Study Definitions Repository API.

    The version of the OpenAPI document: 3.10.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.activity_output import ActivityOutput
from openapi_client.models.alias_code import AliasCode
from openapi_client.models.analysis_population_output import AnalysisPopulationOutput
from openapi_client.models.biomedical_concept_category_output import BiomedicalConceptCategoryOutput
from openapi_client.models.biomedical_concept_output import BiomedicalConceptOutput
from openapi_client.models.biomedical_concept_surrogate_output import BiomedicalConceptSurrogateOutput
from openapi_client.models.biospecimen_retention import BiospecimenRetention
from openapi_client.models.code import Code
from openapi_client.models.comment_annotation import CommentAnnotation
from openapi_client.models.condition_output import ConditionOutput
from openapi_client.models.encounter_output import EncounterOutput
from openapi_client.models.estimand_output import EstimandOutput
from openapi_client.models.indication_output import IndicationOutput
from openapi_client.models.objective_output import ObjectiveOutput
from openapi_client.models.schedule_timeline_output import ScheduleTimelineOutput
from openapi_client.models.study_arm_output import StudyArmOutput
from openapi_client.models.study_cell import StudyCell
from openapi_client.models.study_design_population_output import StudyDesignPopulationOutput
from openapi_client.models.study_element_output import StudyElementOutput
from openapi_client.models.study_epoch_output import StudyEpochOutput
from openapi_client.models.study_intervention_output import StudyInterventionOutput
from openapi_client.models.syntax_template_dictionary import SyntaxTemplateDictionary
from typing import Optional, Set
from typing_extensions import Self

class ObservationalStudyDesignOutput(BaseModel):
    """
    ObservationalStudyDesignOutput
    """ # noqa: E501
    id: Annotated[str, Field(min_length=1, strict=True)]
    name: Annotated[str, Field(min_length=1, strict=True)]
    label: Optional[StrictStr] = None
    description: Optional[StrictStr] = None
    study_type: Optional[Code] = Field(default=None, alias="studyType")
    study_phase: Optional[AliasCode] = Field(default=None, alias="studyPhase")
    therapeutic_areas: Optional[List[Code]] = Field(default=None, alias="therapeuticAreas")
    characteristics: Optional[List[Code]] = None
    encounters: Optional[List[EncounterOutput]] = None
    activities: Optional[List[ActivityOutput]] = None
    biomedical_concepts: Optional[List[BiomedicalConceptOutput]] = Field(default=None, alias="biomedicalConcepts")
    bc_categories: Optional[List[BiomedicalConceptCategoryOutput]] = Field(default=None, alias="bcCategories")
    bc_surrogates: Optional[List[BiomedicalConceptSurrogateOutput]] = Field(default=None, alias="bcSurrogates")
    arms: List[StudyArmOutput]
    study_cells: List[StudyCell] = Field(alias="studyCells")
    rationale: StrictStr
    epochs: List[StudyEpochOutput]
    elements: Optional[List[StudyElementOutput]] = None
    estimands: Optional[List[EstimandOutput]] = None
    indications: Optional[List[IndicationOutput]] = None
    study_interventions: Optional[List[StudyInterventionOutput]] = Field(default=None, alias="studyInterventions")
    objectives: Optional[List[ObjectiveOutput]] = None
    population: Optional[StudyDesignPopulationOutput] = None
    analysis_populations: Optional[List[AnalysisPopulationOutput]] = Field(default=None, alias="analysisPopulations")
    schedule_timelines: Optional[List[ScheduleTimelineOutput]] = Field(default=None, alias="scheduleTimelines")
    biospecimen_retentions: Optional[List[BiospecimenRetention]] = Field(default=None, alias="biospecimenRetentions")
    document_version_ids: Optional[List[StrictStr]] = Field(default=None, alias="documentVersionIds")
    dictionaries: Optional[List[SyntaxTemplateDictionary]] = None
    conditions: Optional[List[ConditionOutput]] = None
    notes: Optional[List[CommentAnnotation]] = None
    instance_type: StrictStr = Field(alias="instanceType")
    sub_types: Optional[List[Code]] = Field(default=None, alias="subTypes")
    model: Code
    time_perspective: Code = Field(alias="timePerspective")
    sampling_method: Optional[Code] = Field(default=None, alias="samplingMethod")
    __properties: ClassVar[List[str]] = ["id", "name", "label", "description", "studyType", "studyPhase", "therapeuticAreas", "characteristics", "encounters", "activities", "biomedicalConcepts", "bcCategories", "bcSurrogates", "arms", "studyCells", "rationale", "epochs", "elements", "estimands", "indications", "studyInterventions", "objectives", "population", "analysisPopulations", "scheduleTimelines", "biospecimenRetentions", "documentVersionIds", "dictionaries", "conditions", "notes", "instanceType", "subTypes", "model", "timePerspective", "samplingMethod"]

    @field_validator('instance_type')
    def instance_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['ObservationalStudyDesign']):
            raise ValueError("must be one of enum values ('ObservationalStudyDesign')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ObservationalStudyDesignOutput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of study_type
        if self.study_type:
            _dict['studyType'] = self.study_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of study_phase
        if self.study_phase:
            _dict['studyPhase'] = self.study_phase.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in therapeutic_areas (list)
        _items = []
        if self.therapeutic_areas:
            for _item_therapeutic_areas in self.therapeutic_areas:
                if _item_therapeutic_areas:
                    _items.append(_item_therapeutic_areas.to_dict())
            _dict['therapeuticAreas'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in characteristics (list)
        _items = []
        if self.characteristics:
            for _item_characteristics in self.characteristics:
                if _item_characteristics:
                    _items.append(_item_characteristics.to_dict())
            _dict['characteristics'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in encounters (list)
        _items = []
        if self.encounters:
            for _item_encounters in self.encounters:
                if _item_encounters:
                    _items.append(_item_encounters.to_dict())
            _dict['encounters'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in activities (list)
        _items = []
        if self.activities:
            for _item_activities in self.activities:
                if _item_activities:
                    _items.append(_item_activities.to_dict())
            _dict['activities'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biomedical_concepts (list)
        _items = []
        if self.biomedical_concepts:
            for _item_biomedical_concepts in self.biomedical_concepts:
                if _item_biomedical_concepts:
                    _items.append(_item_biomedical_concepts.to_dict())
            _dict['biomedicalConcepts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_categories (list)
        _items = []
        if self.bc_categories:
            for _item_bc_categories in self.bc_categories:
                if _item_bc_categories:
                    _items.append(_item_bc_categories.to_dict())
            _dict['bcCategories'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_surrogates (list)
        _items = []
        if self.bc_surrogates:
            for _item_bc_surrogates in self.bc_surrogates:
                if _item_bc_surrogates:
                    _items.append(_item_bc_surrogates.to_dict())
            _dict['bcSurrogates'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in arms (list)
        _items = []
        if self.arms:
            for _item_arms in self.arms:
                if _item_arms:
                    _items.append(_item_arms.to_dict())
            _dict['arms'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_cells (list)
        _items = []
        if self.study_cells:
            for _item_study_cells in self.study_cells:
                if _item_study_cells:
                    _items.append(_item_study_cells.to_dict())
            _dict['studyCells'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in epochs (list)
        _items = []
        if self.epochs:
            for _item_epochs in self.epochs:
                if _item_epochs:
                    _items.append(_item_epochs.to_dict())
            _dict['epochs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in elements (list)
        _items = []
        if self.elements:
            for _item_elements in self.elements:
                if _item_elements:
                    _items.append(_item_elements.to_dict())
            _dict['elements'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in estimands (list)
        _items = []
        if self.estimands:
            for _item_estimands in self.estimands:
                if _item_estimands:
                    _items.append(_item_estimands.to_dict())
            _dict['estimands'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in indications (list)
        _items = []
        if self.indications:
            for _item_indications in self.indications:
                if _item_indications:
                    _items.append(_item_indications.to_dict())
            _dict['indications'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_interventions (list)
        _items = []
        if self.study_interventions:
            for _item_study_interventions in self.study_interventions:
                if _item_study_interventions:
                    _items.append(_item_study_interventions.to_dict())
            _dict['studyInterventions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in objectives (list)
        _items = []
        if self.objectives:
            for _item_objectives in self.objectives:
                if _item_objectives:
                    _items.append(_item_objectives.to_dict())
            _dict['objectives'] = _items
        # override the default output from pydantic by calling `to_dict()` of population
        if self.population:
            _dict['population'] = self.population.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in analysis_populations (list)
        _items = []
        if self.analysis_populations:
            for _item_analysis_populations in self.analysis_populations:
                if _item_analysis_populations:
                    _items.append(_item_analysis_populations.to_dict())
            _dict['analysisPopulations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in schedule_timelines (list)
        _items = []
        if self.schedule_timelines:
            for _item_schedule_timelines in self.schedule_timelines:
                if _item_schedule_timelines:
                    _items.append(_item_schedule_timelines.to_dict())
            _dict['scheduleTimelines'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biospecimen_retentions (list)
        _items = []
        if self.biospecimen_retentions:
            for _item_biospecimen_retentions in self.biospecimen_retentions:
                if _item_biospecimen_retentions:
                    _items.append(_item_biospecimen_retentions.to_dict())
            _dict['biospecimenRetentions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in dictionaries (list)
        _items = []
        if self.dictionaries:
            for _item_dictionaries in self.dictionaries:
                if _item_dictionaries:
                    _items.append(_item_dictionaries.to_dict())
            _dict['dictionaries'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in conditions (list)
        _items = []
        if self.conditions:
            for _item_conditions in self.conditions:
                if _item_conditions:
                    _items.append(_item_conditions.to_dict())
            _dict['conditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in notes (list)
        _items = []
        if self.notes:
            for _item_notes in self.notes:
                if _item_notes:
                    _items.append(_item_notes.to_dict())
            _dict['notes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in sub_types (list)
        _items = []
        if self.sub_types:
            for _item_sub_types in self.sub_types:
                if _item_sub_types:
                    _items.append(_item_sub_types.to_dict())
            _dict['subTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of model
        if self.model:
            _dict['model'] = self.model.to_dict()
        # override the default output from pydantic by calling `to_dict()` of time_perspective
        if self.time_perspective:
            _dict['timePerspective'] = self.time_perspective.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sampling_method
        if self.sampling_method:
            _dict['samplingMethod'] = self.sampling_method.to_dict()
        # set to None if label (nullable) is None
        # and model_fields_set contains the field
        if self.label is None and "label" in self.model_fields_set:
            _dict['label'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if study_type (nullable) is None
        # and model_fields_set contains the field
        if self.study_type is None and "study_type" in self.model_fields_set:
            _dict['studyType'] = None

        # set to None if study_phase (nullable) is None
        # and model_fields_set contains the field
        if self.study_phase is None and "study_phase" in self.model_fields_set:
            _dict['studyPhase'] = None

        # set to None if population (nullable) is None
        # and model_fields_set contains the field
        if self.population is None and "population" in self.model_fields_set:
            _dict['population'] = None

        # set to None if sampling_method (nullable) is None
        # and model_fields_set contains the field
        if self.sampling_method is None and "sampling_method" in self.model_fields_set:
            _dict['samplingMethod'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ObservationalStudyDesignOutput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "label": obj.get("label"),
            "description": obj.get("description"),
            "studyType": Code.from_dict(obj["studyType"]) if obj.get("studyType") is not None else None,
            "studyPhase": AliasCode.from_dict(obj["studyPhase"]) if obj.get("studyPhase") is not None else None,
            "therapeuticAreas": [Code.from_dict(_item) for _item in obj["therapeuticAreas"]] if obj.get("therapeuticAreas") is not None else None,
            "characteristics": [Code.from_dict(_item) for _item in obj["characteristics"]] if obj.get("characteristics") is not None else None,
            "encounters": [EncounterOutput.from_dict(_item) for _item in obj["encounters"]] if obj.get("encounters") is not None else None,
            "activities": [ActivityOutput.from_dict(_item) for _item in obj["activities"]] if obj.get("activities") is not None else None,
            "biomedicalConcepts": [BiomedicalConceptOutput.from_dict(_item) for _item in obj["biomedicalConcepts"]] if obj.get("biomedicalConcepts") is not None else None,
            "bcCategories": [BiomedicalConceptCategoryOutput.from_dict(_item) for _item in obj["bcCategories"]] if obj.get("bcCategories") is not None else None,
            "bcSurrogates": [BiomedicalConceptSurrogateOutput.from_dict(_item) for _item in obj["bcSurrogates"]] if obj.get("bcSurrogates") is not None else None,
            "arms": [StudyArmOutput.from_dict(_item) for _item in obj["arms"]] if obj.get("arms") is not None else None,
            "studyCells": [StudyCell.from_dict(_item) for _item in obj["studyCells"]] if obj.get("studyCells") is not None else None,
            "rationale": obj.get("rationale"),
            "epochs": [StudyEpochOutput.from_dict(_item) for _item in obj["epochs"]] if obj.get("epochs") is not None else None,
            "elements": [StudyElementOutput.from_dict(_item) for _item in obj["elements"]] if obj.get("elements") is not None else None,
            "estimands": [EstimandOutput.from_dict(_item) for _item in obj["estimands"]] if obj.get("estimands") is not None else None,
            "indications": [IndicationOutput.from_dict(_item) for _item in obj["indications"]] if obj.get("indications") is not None else None,
            "studyInterventions": [StudyInterventionOutput.from_dict(_item) for _item in obj["studyInterventions"]] if obj.get("studyInterventions") is not None else None,
            "objectives": [ObjectiveOutput.from_dict(_item) for _item in obj["objectives"]] if obj.get("objectives") is not None else None,
            "population": StudyDesignPopulationOutput.from_dict(obj["population"]) if obj.get("population") is not None else None,
            "analysisPopulations": [AnalysisPopulationOutput.from_dict(_item) for _item in obj["analysisPopulations"]] if obj.get("analysisPopulations") is not None else None,
            "scheduleTimelines": [ScheduleTimelineOutput.from_dict(_item) for _item in obj["scheduleTimelines"]] if obj.get("scheduleTimelines") is not None else None,
            "biospecimenRetentions": [BiospecimenRetention.from_dict(_item) for _item in obj["biospecimenRetentions"]] if obj.get("biospecimenRetentions") is not None else None,
            "documentVersionIds": obj.get("documentVersionIds"),
            "dictionaries": [SyntaxTemplateDictionary.from_dict(_item) for _item in obj["dictionaries"]] if obj.get("dictionaries") is not None else None,
            "conditions": [ConditionOutput.from_dict(_item) for _item in obj["conditions"]] if obj.get("conditions") is not None else None,
            "notes": [CommentAnnotation.from_dict(_item) for _item in obj["notes"]] if obj.get("notes") is not None else None,
            "instanceType": obj.get("instanceType"),
            "subTypes": [Code.from_dict(_item) for _item in obj["subTypes"]] if obj.get("subTypes") is not None else None,
            "model": Code.from_dict(obj["model"]) if obj.get("model") is not None else None,
            "timePerspective": Code.from_dict(obj["timePerspective"]) if obj.get("timePerspective") is not None else None,
            "samplingMethod": Code.from_dict(obj["samplingMethod"]) if obj.get("samplingMethod") is not None else None
        })
        return _obj


