# coding: utf-8

"""
    DDF USDM API

    A simple TransCelerate Digital Data Flow (DDF) Study Definitions Repository API.

    The version of the OpenAPI document: 3.10.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.activity_input import ActivityInput
from openapi_client.models.alias_code import AliasCode
from openapi_client.models.analysis_population_input import AnalysisPopulationInput
from openapi_client.models.biomedical_concept_category_input import BiomedicalConceptCategoryInput
from openapi_client.models.biomedical_concept_input import BiomedicalConceptInput
from openapi_client.models.biomedical_concept_surrogate_input import BiomedicalConceptSurrogateInput
from openapi_client.models.biospecimen_retention import BiospecimenRetention
from openapi_client.models.code import Code
from openapi_client.models.comment_annotation import CommentAnnotation
from openapi_client.models.condition_input import ConditionInput
from openapi_client.models.encounter_input import EncounterInput
from openapi_client.models.estimand_input import EstimandInput
from openapi_client.models.indication_input import IndicationInput
from openapi_client.models.objective_input import ObjectiveInput
from openapi_client.models.schedule_timeline_input import ScheduleTimelineInput
from openapi_client.models.study_arm_input import StudyArmInput
from openapi_client.models.study_cell import StudyCell
from openapi_client.models.study_design_population_input import StudyDesignPopulationInput
from openapi_client.models.study_element_input import StudyElementInput
from openapi_client.models.study_epoch_input import StudyEpochInput
from openapi_client.models.study_intervention_input import StudyInterventionInput
from openapi_client.models.syntax_template_dictionary import SyntaxTemplateDictionary
from typing import Optional, Set
from typing_extensions import Self

class InterventionalStudyDesignInput(BaseModel):
    """
    InterventionalStudyDesignInput
    """ # noqa: E501
    id: Annotated[str, Field(min_length=1, strict=True)]
    name: Annotated[str, Field(min_length=1, strict=True)]
    label: Optional[StrictStr] = None
    description: Optional[StrictStr] = None
    study_type: Optional[Code] = Field(default=None, alias="studyType")
    study_phase: Optional[AliasCode] = Field(default=None, alias="studyPhase")
    therapeutic_areas: Optional[List[Code]] = Field(default=None, alias="therapeuticAreas")
    characteristics: Optional[List[Code]] = None
    encounters: Optional[List[EncounterInput]] = None
    activities: Optional[List[ActivityInput]] = None
    biomedical_concepts: Optional[List[BiomedicalConceptInput]] = Field(default=None, alias="biomedicalConcepts")
    bc_categories: Optional[List[BiomedicalConceptCategoryInput]] = Field(default=None, alias="bcCategories")
    bc_surrogates: Optional[List[BiomedicalConceptSurrogateInput]] = Field(default=None, alias="bcSurrogates")
    arms: List[StudyArmInput]
    study_cells: List[StudyCell] = Field(alias="studyCells")
    rationale: StrictStr
    epochs: List[StudyEpochInput]
    elements: Optional[List[StudyElementInput]] = None
    estimands: Optional[List[EstimandInput]] = None
    indications: Optional[List[IndicationInput]] = None
    study_interventions: Optional[List[StudyInterventionInput]] = Field(default=None, alias="studyInterventions")
    objectives: Optional[List[ObjectiveInput]] = None
    population: Optional[StudyDesignPopulationInput] = None
    analysis_populations: Optional[List[AnalysisPopulationInput]] = Field(default=None, alias="analysisPopulations")
    schedule_timelines: Optional[List[ScheduleTimelineInput]] = Field(default=None, alias="scheduleTimelines")
    biospecimen_retentions: Optional[List[BiospecimenRetention]] = Field(default=None, alias="biospecimenRetentions")
    document_version_ids: Optional[List[Optional[StrictStr]]] = Field(default=None, alias="documentVersionIds")
    dictionaries: Optional[List[SyntaxTemplateDictionary]] = None
    conditions: Optional[List[ConditionInput]] = None
    notes: Optional[List[CommentAnnotation]] = None
    instance_type: StrictStr = Field(alias="instanceType")
    sub_types: Optional[List[Code]] = Field(default=None, alias="subTypes")
    model: Code
    intent_types: Optional[List[Code]] = Field(default=None, alias="intentTypes")
    blinding_schema: Optional[AliasCode] = Field(default=None, alias="blindingSchema")
    __properties: ClassVar[List[str]] = ["id", "name", "label", "description", "studyType", "studyPhase", "therapeuticAreas", "characteristics", "encounters", "activities", "biomedicalConcepts", "bcCategories", "bcSurrogates", "arms", "studyCells", "rationale", "epochs", "elements", "estimands", "indications", "studyInterventions", "objectives", "population", "analysisPopulations", "scheduleTimelines", "biospecimenRetentions", "documentVersionIds", "dictionaries", "conditions", "notes", "instanceType", "subTypes", "model", "intentTypes", "blindingSchema"]

    @field_validator('instance_type')
    def instance_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['InterventionalStudyDesign']):
            raise ValueError("must be one of enum values ('InterventionalStudyDesign')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of InterventionalStudyDesignInput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of study_type
        if self.study_type:
            _dict['studyType'] = self.study_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of study_phase
        if self.study_phase:
            _dict['studyPhase'] = self.study_phase.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in therapeutic_areas (list)
        _items = []
        if self.therapeutic_areas:
            for _item_therapeutic_areas in self.therapeutic_areas:
                if _item_therapeutic_areas:
                    _items.append(_item_therapeutic_areas.to_dict())
            _dict['therapeuticAreas'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in characteristics (list)
        _items = []
        if self.characteristics:
            for _item_characteristics in self.characteristics:
                if _item_characteristics:
                    _items.append(_item_characteristics.to_dict())
            _dict['characteristics'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in encounters (list)
        _items = []
        if self.encounters:
            for _item_encounters in self.encounters:
                if _item_encounters:
                    _items.append(_item_encounters.to_dict())
            _dict['encounters'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in activities (list)
        _items = []
        if self.activities:
            for _item_activities in self.activities:
                if _item_activities:
                    _items.append(_item_activities.to_dict())
            _dict['activities'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biomedical_concepts (list)
        _items = []
        if self.biomedical_concepts:
            for _item_biomedical_concepts in self.biomedical_concepts:
                if _item_biomedical_concepts:
                    _items.append(_item_biomedical_concepts.to_dict())
            _dict['biomedicalConcepts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_categories (list)
        _items = []
        if self.bc_categories:
            for _item_bc_categories in self.bc_categories:
                if _item_bc_categories:
                    _items.append(_item_bc_categories.to_dict())
            _dict['bcCategories'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_surrogates (list)
        _items = []
        if self.bc_surrogates:
            for _item_bc_surrogates in self.bc_surrogates:
                if _item_bc_surrogates:
                    _items.append(_item_bc_surrogates.to_dict())
            _dict['bcSurrogates'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in arms (list)
        _items = []
        if self.arms:
            for _item_arms in self.arms:
                if _item_arms:
                    _items.append(_item_arms.to_dict())
            _dict['arms'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_cells (list)
        _items = []
        if self.study_cells:
            for _item_study_cells in self.study_cells:
                if _item_study_cells:
                    _items.append(_item_study_cells.to_dict())
            _dict['studyCells'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in epochs (list)
        _items = []
        if self.epochs:
            for _item_epochs in self.epochs:
                if _item_epochs:
                    _items.append(_item_epochs.to_dict())
            _dict['epochs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in elements (list)
        _items = []
        if self.elements:
            for _item_elements in self.elements:
                if _item_elements:
                    _items.append(_item_elements.to_dict())
            _dict['elements'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in estimands (list)
        _items = []
        if self.estimands:
            for _item_estimands in self.estimands:
                if _item_estimands:
                    _items.append(_item_estimands.to_dict())
            _dict['estimands'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in indications (list)
        _items = []
        if self.indications:
            for _item_indications in self.indications:
                if _item_indications:
                    _items.append(_item_indications.to_dict())
            _dict['indications'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_interventions (list)
        _items = []
        if self.study_interventions:
            for _item_study_interventions in self.study_interventions:
                if _item_study_interventions:
                    _items.append(_item_study_interventions.to_dict())
            _dict['studyInterventions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in objectives (list)
        _items = []
        if self.objectives:
            for _item_objectives in self.objectives:
                if _item_objectives:
                    _items.append(_item_objectives.to_dict())
            _dict['objectives'] = _items
        # override the default output from pydantic by calling `to_dict()` of population
        if self.population:
            _dict['population'] = self.population.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in analysis_populations (list)
        _items = []
        if self.analysis_populations:
            for _item_analysis_populations in self.analysis_populations:
                if _item_analysis_populations:
                    _items.append(_item_analysis_populations.to_dict())
            _dict['analysisPopulations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in schedule_timelines (list)
        _items = []
        if self.schedule_timelines:
            for _item_schedule_timelines in self.schedule_timelines:
                if _item_schedule_timelines:
                    _items.append(_item_schedule_timelines.to_dict())
            _dict['scheduleTimelines'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biospecimen_retentions (list)
        _items = []
        if self.biospecimen_retentions:
            for _item_biospecimen_retentions in self.biospecimen_retentions:
                if _item_biospecimen_retentions:
                    _items.append(_item_biospecimen_retentions.to_dict())
            _dict['biospecimenRetentions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in dictionaries (list)
        _items = []
        if self.dictionaries:
            for _item_dictionaries in self.dictionaries:
                if _item_dictionaries:
                    _items.append(_item_dictionaries.to_dict())
            _dict['dictionaries'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in conditions (list)
        _items = []
        if self.conditions:
            for _item_conditions in self.conditions:
                if _item_conditions:
                    _items.append(_item_conditions.to_dict())
            _dict['conditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in notes (list)
        _items = []
        if self.notes:
            for _item_notes in self.notes:
                if _item_notes:
                    _items.append(_item_notes.to_dict())
            _dict['notes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in sub_types (list)
        _items = []
        if self.sub_types:
            for _item_sub_types in self.sub_types:
                if _item_sub_types:
                    _items.append(_item_sub_types.to_dict())
            _dict['subTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of model
        if self.model:
            _dict['model'] = self.model.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in intent_types (list)
        _items = []
        if self.intent_types:
            for _item_intent_types in self.intent_types:
                if _item_intent_types:
                    _items.append(_item_intent_types.to_dict())
            _dict['intentTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of blinding_schema
        if self.blinding_schema:
            _dict['blindingSchema'] = self.blinding_schema.to_dict()
        # set to None if label (nullable) is None
        # and model_fields_set contains the field
        if self.label is None and "label" in self.model_fields_set:
            _dict['label'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if study_type (nullable) is None
        # and model_fields_set contains the field
        if self.study_type is None and "study_type" in self.model_fields_set:
            _dict['studyType'] = None

        # set to None if study_phase (nullable) is None
        # and model_fields_set contains the field
        if self.study_phase is None and "study_phase" in self.model_fields_set:
            _dict['studyPhase'] = None

        # set to None if population (nullable) is None
        # and model_fields_set contains the field
        if self.population is None and "population" in self.model_fields_set:
            _dict['population'] = None

        # set to None if blinding_schema (nullable) is None
        # and model_fields_set contains the field
        if self.blinding_schema is None and "blinding_schema" in self.model_fields_set:
            _dict['blindingSchema'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of InterventionalStudyDesignInput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "label": obj.get("label"),
            "description": obj.get("description"),
            "studyType": Code.from_dict(obj["studyType"]) if obj.get("studyType") is not None else None,
            "studyPhase": AliasCode.from_dict(obj["studyPhase"]) if obj.get("studyPhase") is not None else None,
            "therapeuticAreas": [Code.from_dict(_item) for _item in obj["therapeuticAreas"]] if obj.get("therapeuticAreas") is not None else None,
            "characteristics": [Code.from_dict(_item) for _item in obj["characteristics"]] if obj.get("characteristics") is not None else None,
            "encounters": [EncounterInput.from_dict(_item) for _item in obj["encounters"]] if obj.get("encounters") is not None else None,
            "activities": [ActivityInput.from_dict(_item) for _item in obj["activities"]] if obj.get("activities") is not None else None,
            "biomedicalConcepts": [BiomedicalConceptInput.from_dict(_item) for _item in obj["biomedicalConcepts"]] if obj.get("biomedicalConcepts") is not None else None,
            "bcCategories": [BiomedicalConceptCategoryInput.from_dict(_item) for _item in obj["bcCategories"]] if obj.get("bcCategories") is not None else None,
            "bcSurrogates": [BiomedicalConceptSurrogateInput.from_dict(_item) for _item in obj["bcSurrogates"]] if obj.get("bcSurrogates") is not None else None,
            "arms": [StudyArmInput.from_dict(_item) for _item in obj["arms"]] if obj.get("arms") is not None else None,
            "studyCells": [StudyCell.from_dict(_item) for _item in obj["studyCells"]] if obj.get("studyCells") is not None else None,
            "rationale": obj.get("rationale"),
            "epochs": [StudyEpochInput.from_dict(_item) for _item in obj["epochs"]] if obj.get("epochs") is not None else None,
            "elements": [StudyElementInput.from_dict(_item) for _item in obj["elements"]] if obj.get("elements") is not None else None,
            "estimands": [EstimandInput.from_dict(_item) for _item in obj["estimands"]] if obj.get("estimands") is not None else None,
            "indications": [IndicationInput.from_dict(_item) for _item in obj["indications"]] if obj.get("indications") is not None else None,
            "studyInterventions": [StudyInterventionInput.from_dict(_item) for _item in obj["studyInterventions"]] if obj.get("studyInterventions") is not None else None,
            "objectives": [ObjectiveInput.from_dict(_item) for _item in obj["objectives"]] if obj.get("objectives") is not None else None,
            "population": StudyDesignPopulationInput.from_dict(obj["population"]) if obj.get("population") is not None else None,
            "analysisPopulations": [AnalysisPopulationInput.from_dict(_item) for _item in obj["analysisPopulations"]] if obj.get("analysisPopulations") is not None else None,
            "scheduleTimelines": [ScheduleTimelineInput.from_dict(_item) for _item in obj["scheduleTimelines"]] if obj.get("scheduleTimelines") is not None else None,
            "biospecimenRetentions": [BiospecimenRetention.from_dict(_item) for _item in obj["biospecimenRetentions"]] if obj.get("biospecimenRetentions") is not None else None,
            "documentVersionIds": obj.get("documentVersionIds"),
            "dictionaries": [SyntaxTemplateDictionary.from_dict(_item) for _item in obj["dictionaries"]] if obj.get("dictionaries") is not None else None,
            "conditions": [ConditionInput.from_dict(_item) for _item in obj["conditions"]] if obj.get("conditions") is not None else None,
            "notes": [CommentAnnotation.from_dict(_item) for _item in obj["notes"]] if obj.get("notes") is not None else None,
            "instanceType": obj.get("instanceType"),
            "subTypes": [Code.from_dict(_item) for _item in obj["subTypes"]] if obj.get("subTypes") is not None else None,
            "model": Code.from_dict(obj["model"]) if obj.get("model") is not None else None,
            "intentTypes": [Code.from_dict(_item) for _item in obj["intentTypes"]] if obj.get("intentTypes") is not None else None,
            "blindingSchema": AliasCode.from_dict(obj["blindingSchema"]) if obj.get("blindingSchema") is not None else None
        })
        return _obj


