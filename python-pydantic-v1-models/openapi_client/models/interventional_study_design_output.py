# coding: utf-8

"""
    DDF USDM API

    A simple TransCelerate Digital Data Flow (DDF) Study Definitions Repository API.

    The version of the OpenAPI document: 3.10.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
from openapi_client.models.activity_output import ActivityOutput
from openapi_client.models.alias_code import AliasCode
from openapi_client.models.analysis_population_output import AnalysisPopulationOutput
from openapi_client.models.biomedical_concept_category_output import BiomedicalConceptCategoryOutput
from openapi_client.models.biomedical_concept_output import BiomedicalConceptOutput
from openapi_client.models.biomedical_concept_surrogate_output import BiomedicalConceptSurrogateOutput
from openapi_client.models.biospecimen_retention import BiospecimenRetention
from openapi_client.models.code import Code
from openapi_client.models.comment_annotation import CommentAnnotation
from openapi_client.models.condition_output import ConditionOutput
from openapi_client.models.encounter_output import EncounterOutput
from openapi_client.models.estimand_output import EstimandOutput
from openapi_client.models.indication_output import IndicationOutput
from openapi_client.models.objective_output import ObjectiveOutput
from openapi_client.models.schedule_timeline_output import ScheduleTimelineOutput
from openapi_client.models.study_arm_output import StudyArmOutput
from openapi_client.models.study_cell import StudyCell
from openapi_client.models.study_design_population_output import StudyDesignPopulationOutput
from openapi_client.models.study_element_output import StudyElementOutput
from openapi_client.models.study_epoch_output import StudyEpochOutput
from openapi_client.models.study_intervention_output import StudyInterventionOutput
from openapi_client.models.syntax_template_dictionary import SyntaxTemplateDictionary

class InterventionalStudyDesignOutput(BaseModel):
    """
    InterventionalStudyDesignOutput
    """
    id: constr(strict=True, min_length=1) = Field(...)
    name: constr(strict=True, min_length=1) = Field(...)
    label: Optional[StrictStr] = None
    description: Optional[StrictStr] = None
    study_type: Optional[Code] = Field(default=None, alias="studyType")
    study_phase: Optional[AliasCode] = Field(default=None, alias="studyPhase")
    therapeutic_areas: Optional[conlist(Code)] = Field(default=None, alias="therapeuticAreas")
    characteristics: Optional[conlist(Code)] = None
    encounters: Optional[conlist(EncounterOutput)] = None
    activities: Optional[conlist(ActivityOutput)] = None
    biomedical_concepts: Optional[conlist(BiomedicalConceptOutput)] = Field(default=None, alias="biomedicalConcepts")
    bc_categories: Optional[conlist(BiomedicalConceptCategoryOutput)] = Field(default=None, alias="bcCategories")
    bc_surrogates: Optional[conlist(BiomedicalConceptSurrogateOutput)] = Field(default=None, alias="bcSurrogates")
    arms: conlist(StudyArmOutput) = Field(...)
    study_cells: conlist(StudyCell) = Field(default=..., alias="studyCells")
    rationale: StrictStr = Field(...)
    epochs: conlist(StudyEpochOutput) = Field(...)
    elements: Optional[conlist(StudyElementOutput)] = None
    estimands: Optional[conlist(EstimandOutput)] = None
    indications: Optional[conlist(IndicationOutput)] = None
    study_interventions: Optional[conlist(StudyInterventionOutput)] = Field(default=None, alias="studyInterventions")
    objectives: Optional[conlist(ObjectiveOutput)] = None
    population: Optional[StudyDesignPopulationOutput] = None
    analysis_populations: Optional[conlist(AnalysisPopulationOutput)] = Field(default=None, alias="analysisPopulations")
    schedule_timelines: Optional[conlist(ScheduleTimelineOutput)] = Field(default=None, alias="scheduleTimelines")
    biospecimen_retentions: Optional[conlist(BiospecimenRetention)] = Field(default=None, alias="biospecimenRetentions")
    document_version_ids: Optional[conlist(StrictStr)] = Field(default=None, alias="documentVersionIds")
    dictionaries: Optional[conlist(SyntaxTemplateDictionary)] = None
    conditions: Optional[conlist(ConditionOutput)] = None
    notes: Optional[conlist(CommentAnnotation)] = None
    instance_type: StrictStr = Field(default=..., alias="instanceType")
    sub_types: Optional[conlist(Code)] = Field(default=None, alias="subTypes")
    model: Code = Field(...)
    intent_types: Optional[conlist(Code)] = Field(default=None, alias="intentTypes")
    blinding_schema: Optional[AliasCode] = Field(default=None, alias="blindingSchema")
    __properties = ["id", "name", "label", "description", "studyType", "studyPhase", "therapeuticAreas", "characteristics", "encounters", "activities", "biomedicalConcepts", "bcCategories", "bcSurrogates", "arms", "studyCells", "rationale", "epochs", "elements", "estimands", "indications", "studyInterventions", "objectives", "population", "analysisPopulations", "scheduleTimelines", "biospecimenRetentions", "documentVersionIds", "dictionaries", "conditions", "notes", "instanceType", "subTypes", "model", "intentTypes", "blindingSchema"]

    @validator('instance_type')
    def instance_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('InterventionalStudyDesign',):
            raise ValueError("must be one of enum values ('InterventionalStudyDesign')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> InterventionalStudyDesignOutput:
        """Create an instance of InterventionalStudyDesignOutput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of study_type
        if self.study_type:
            _dict['studyType'] = self.study_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of study_phase
        if self.study_phase:
            _dict['studyPhase'] = self.study_phase.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in therapeutic_areas (list)
        _items = []
        if self.therapeutic_areas:
            for _item in self.therapeutic_areas:
                if _item:
                    _items.append(_item.to_dict())
            _dict['therapeuticAreas'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in characteristics (list)
        _items = []
        if self.characteristics:
            for _item in self.characteristics:
                if _item:
                    _items.append(_item.to_dict())
            _dict['characteristics'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in encounters (list)
        _items = []
        if self.encounters:
            for _item in self.encounters:
                if _item:
                    _items.append(_item.to_dict())
            _dict['encounters'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in activities (list)
        _items = []
        if self.activities:
            for _item in self.activities:
                if _item:
                    _items.append(_item.to_dict())
            _dict['activities'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biomedical_concepts (list)
        _items = []
        if self.biomedical_concepts:
            for _item in self.biomedical_concepts:
                if _item:
                    _items.append(_item.to_dict())
            _dict['biomedicalConcepts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_categories (list)
        _items = []
        if self.bc_categories:
            for _item in self.bc_categories:
                if _item:
                    _items.append(_item.to_dict())
            _dict['bcCategories'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_surrogates (list)
        _items = []
        if self.bc_surrogates:
            for _item in self.bc_surrogates:
                if _item:
                    _items.append(_item.to_dict())
            _dict['bcSurrogates'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in arms (list)
        _items = []
        if self.arms:
            for _item in self.arms:
                if _item:
                    _items.append(_item.to_dict())
            _dict['arms'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_cells (list)
        _items = []
        if self.study_cells:
            for _item in self.study_cells:
                if _item:
                    _items.append(_item.to_dict())
            _dict['studyCells'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in epochs (list)
        _items = []
        if self.epochs:
            for _item in self.epochs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['epochs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in elements (list)
        _items = []
        if self.elements:
            for _item in self.elements:
                if _item:
                    _items.append(_item.to_dict())
            _dict['elements'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in estimands (list)
        _items = []
        if self.estimands:
            for _item in self.estimands:
                if _item:
                    _items.append(_item.to_dict())
            _dict['estimands'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in indications (list)
        _items = []
        if self.indications:
            for _item in self.indications:
                if _item:
                    _items.append(_item.to_dict())
            _dict['indications'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_interventions (list)
        _items = []
        if self.study_interventions:
            for _item in self.study_interventions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['studyInterventions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in objectives (list)
        _items = []
        if self.objectives:
            for _item in self.objectives:
                if _item:
                    _items.append(_item.to_dict())
            _dict['objectives'] = _items
        # override the default output from pydantic by calling `to_dict()` of population
        if self.population:
            _dict['population'] = self.population.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in analysis_populations (list)
        _items = []
        if self.analysis_populations:
            for _item in self.analysis_populations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['analysisPopulations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in schedule_timelines (list)
        _items = []
        if self.schedule_timelines:
            for _item in self.schedule_timelines:
                if _item:
                    _items.append(_item.to_dict())
            _dict['scheduleTimelines'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biospecimen_retentions (list)
        _items = []
        if self.biospecimen_retentions:
            for _item in self.biospecimen_retentions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['biospecimenRetentions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in dictionaries (list)
        _items = []
        if self.dictionaries:
            for _item in self.dictionaries:
                if _item:
                    _items.append(_item.to_dict())
            _dict['dictionaries'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in conditions (list)
        _items = []
        if self.conditions:
            for _item in self.conditions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['conditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in notes (list)
        _items = []
        if self.notes:
            for _item in self.notes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['notes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in sub_types (list)
        _items = []
        if self.sub_types:
            for _item in self.sub_types:
                if _item:
                    _items.append(_item.to_dict())
            _dict['subTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of model
        if self.model:
            _dict['model'] = self.model.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in intent_types (list)
        _items = []
        if self.intent_types:
            for _item in self.intent_types:
                if _item:
                    _items.append(_item.to_dict())
            _dict['intentTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of blinding_schema
        if self.blinding_schema:
            _dict['blindingSchema'] = self.blinding_schema.to_dict()
        # set to None if label (nullable) is None
        # and __fields_set__ contains the field
        if self.label is None and "label" in self.__fields_set__:
            _dict['label'] = None

        # set to None if description (nullable) is None
        # and __fields_set__ contains the field
        if self.description is None and "description" in self.__fields_set__:
            _dict['description'] = None

        # set to None if study_type (nullable) is None
        # and __fields_set__ contains the field
        if self.study_type is None and "study_type" in self.__fields_set__:
            _dict['studyType'] = None

        # set to None if study_phase (nullable) is None
        # and __fields_set__ contains the field
        if self.study_phase is None and "study_phase" in self.__fields_set__:
            _dict['studyPhase'] = None

        # set to None if population (nullable) is None
        # and __fields_set__ contains the field
        if self.population is None and "population" in self.__fields_set__:
            _dict['population'] = None

        # set to None if blinding_schema (nullable) is None
        # and __fields_set__ contains the field
        if self.blinding_schema is None and "blinding_schema" in self.__fields_set__:
            _dict['blindingSchema'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> InterventionalStudyDesignOutput:
        """Create an instance of InterventionalStudyDesignOutput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return InterventionalStudyDesignOutput.parse_obj(obj)

        _obj = InterventionalStudyDesignOutput.parse_obj({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "label": obj.get("label"),
            "description": obj.get("description"),
            "study_type": Code.from_dict(obj.get("studyType")) if obj.get("studyType") is not None else None,
            "study_phase": AliasCode.from_dict(obj.get("studyPhase")) if obj.get("studyPhase") is not None else None,
            "therapeutic_areas": [Code.from_dict(_item) for _item in obj.get("therapeuticAreas")] if obj.get("therapeuticAreas") is not None else None,
            "characteristics": [Code.from_dict(_item) for _item in obj.get("characteristics")] if obj.get("characteristics") is not None else None,
            "encounters": [EncounterOutput.from_dict(_item) for _item in obj.get("encounters")] if obj.get("encounters") is not None else None,
            "activities": [ActivityOutput.from_dict(_item) for _item in obj.get("activities")] if obj.get("activities") is not None else None,
            "biomedical_concepts": [BiomedicalConceptOutput.from_dict(_item) for _item in obj.get("biomedicalConcepts")] if obj.get("biomedicalConcepts") is not None else None,
            "bc_categories": [BiomedicalConceptCategoryOutput.from_dict(_item) for _item in obj.get("bcCategories")] if obj.get("bcCategories") is not None else None,
            "bc_surrogates": [BiomedicalConceptSurrogateOutput.from_dict(_item) for _item in obj.get("bcSurrogates")] if obj.get("bcSurrogates") is not None else None,
            "arms": [StudyArmOutput.from_dict(_item) for _item in obj.get("arms")] if obj.get("arms") is not None else None,
            "study_cells": [StudyCell.from_dict(_item) for _item in obj.get("studyCells")] if obj.get("studyCells") is not None else None,
            "rationale": obj.get("rationale"),
            "epochs": [StudyEpochOutput.from_dict(_item) for _item in obj.get("epochs")] if obj.get("epochs") is not None else None,
            "elements": [StudyElementOutput.from_dict(_item) for _item in obj.get("elements")] if obj.get("elements") is not None else None,
            "estimands": [EstimandOutput.from_dict(_item) for _item in obj.get("estimands")] if obj.get("estimands") is not None else None,
            "indications": [IndicationOutput.from_dict(_item) for _item in obj.get("indications")] if obj.get("indications") is not None else None,
            "study_interventions": [StudyInterventionOutput.from_dict(_item) for _item in obj.get("studyInterventions")] if obj.get("studyInterventions") is not None else None,
            "objectives": [ObjectiveOutput.from_dict(_item) for _item in obj.get("objectives")] if obj.get("objectives") is not None else None,
            "population": StudyDesignPopulationOutput.from_dict(obj.get("population")) if obj.get("population") is not None else None,
            "analysis_populations": [AnalysisPopulationOutput.from_dict(_item) for _item in obj.get("analysisPopulations")] if obj.get("analysisPopulations") is not None else None,
            "schedule_timelines": [ScheduleTimelineOutput.from_dict(_item) for _item in obj.get("scheduleTimelines")] if obj.get("scheduleTimelines") is not None else None,
            "biospecimen_retentions": [BiospecimenRetention.from_dict(_item) for _item in obj.get("biospecimenRetentions")] if obj.get("biospecimenRetentions") is not None else None,
            "document_version_ids": obj.get("documentVersionIds"),
            "dictionaries": [SyntaxTemplateDictionary.from_dict(_item) for _item in obj.get("dictionaries")] if obj.get("dictionaries") is not None else None,
            "conditions": [ConditionOutput.from_dict(_item) for _item in obj.get("conditions")] if obj.get("conditions") is not None else None,
            "notes": [CommentAnnotation.from_dict(_item) for _item in obj.get("notes")] if obj.get("notes") is not None else None,
            "instance_type": obj.get("instanceType"),
            "sub_types": [Code.from_dict(_item) for _item in obj.get("subTypes")] if obj.get("subTypes") is not None else None,
            "model": Code.from_dict(obj.get("model")) if obj.get("model") is not None else None,
            "intent_types": [Code.from_dict(_item) for _item in obj.get("intentTypes")] if obj.get("intentTypes") is not None else None,
            "blinding_schema": AliasCode.from_dict(obj.get("blindingSchema")) if obj.get("blindingSchema") is not None else None
        })
        return _obj


