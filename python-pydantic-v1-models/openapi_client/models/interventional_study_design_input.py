# coding: utf-8

"""
    DDF USDM API

    A simple TransCelerate Digital Data Flow (DDF) Study Definitions Repository API.

    The version of the OpenAPI document: 3.10.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
from openapi_client.models.activity_input import ActivityInput
from openapi_client.models.alias_code import AliasCode
from openapi_client.models.analysis_population_input import AnalysisPopulationInput
from openapi_client.models.biomedical_concept_category_input import BiomedicalConceptCategoryInput
from openapi_client.models.biomedical_concept_input import BiomedicalConceptInput
from openapi_client.models.biomedical_concept_surrogate_input import BiomedicalConceptSurrogateInput
from openapi_client.models.biospecimen_retention import BiospecimenRetention
from openapi_client.models.code import Code
from openapi_client.models.comment_annotation import CommentAnnotation
from openapi_client.models.condition_input import ConditionInput
from openapi_client.models.encounter_input import EncounterInput
from openapi_client.models.estimand_input import EstimandInput
from openapi_client.models.indication_input import IndicationInput
from openapi_client.models.objective_input import ObjectiveInput
from openapi_client.models.schedule_timeline_input import ScheduleTimelineInput
from openapi_client.models.study_arm_input import StudyArmInput
from openapi_client.models.study_cell import StudyCell
from openapi_client.models.study_design_population_input import StudyDesignPopulationInput
from openapi_client.models.study_element_input import StudyElementInput
from openapi_client.models.study_epoch_input import StudyEpochInput
from openapi_client.models.study_intervention_input import StudyInterventionInput
from openapi_client.models.syntax_template_dictionary import SyntaxTemplateDictionary

class InterventionalStudyDesignInput(BaseModel):
    """
    InterventionalStudyDesignInput
    """
    id: constr(strict=True, min_length=1) = Field(...)
    name: constr(strict=True, min_length=1) = Field(...)
    label: Optional[StrictStr] = None
    description: Optional[StrictStr] = None
    study_type: Optional[Code] = Field(default=None, alias="studyType")
    study_phase: Optional[AliasCode] = Field(default=None, alias="studyPhase")
    therapeutic_areas: Optional[conlist(Code)] = Field(default=None, alias="therapeuticAreas")
    characteristics: Optional[conlist(Code)] = None
    encounters: Optional[conlist(EncounterInput)] = None
    activities: Optional[conlist(ActivityInput)] = None
    biomedical_concepts: Optional[conlist(BiomedicalConceptInput)] = Field(default=None, alias="biomedicalConcepts")
    bc_categories: Optional[conlist(BiomedicalConceptCategoryInput)] = Field(default=None, alias="bcCategories")
    bc_surrogates: Optional[conlist(BiomedicalConceptSurrogateInput)] = Field(default=None, alias="bcSurrogates")
    arms: conlist(StudyArmInput) = Field(...)
    study_cells: conlist(StudyCell) = Field(default=..., alias="studyCells")
    rationale: StrictStr = Field(...)
    epochs: conlist(StudyEpochInput) = Field(...)
    elements: Optional[conlist(StudyElementInput)] = None
    estimands: Optional[conlist(EstimandInput)] = None
    indications: Optional[conlist(IndicationInput)] = None
    study_interventions: Optional[conlist(StudyInterventionInput)] = Field(default=None, alias="studyInterventions")
    objectives: Optional[conlist(ObjectiveInput)] = None
    population: Optional[StudyDesignPopulationInput] = None
    analysis_populations: Optional[conlist(AnalysisPopulationInput)] = Field(default=None, alias="analysisPopulations")
    schedule_timelines: Optional[conlist(ScheduleTimelineInput)] = Field(default=None, alias="scheduleTimelines")
    biospecimen_retentions: Optional[conlist(BiospecimenRetention)] = Field(default=None, alias="biospecimenRetentions")
    document_version_ids: Optional[conlist(StrictStr)] = Field(default=None, alias="documentVersionIds")
    dictionaries: Optional[conlist(SyntaxTemplateDictionary)] = None
    conditions: Optional[conlist(ConditionInput)] = None
    notes: Optional[conlist(CommentAnnotation)] = None
    instance_type: StrictStr = Field(default=..., alias="instanceType")
    sub_types: Optional[conlist(Code)] = Field(default=None, alias="subTypes")
    model: Code = Field(...)
    intent_types: Optional[conlist(Code)] = Field(default=None, alias="intentTypes")
    blinding_schema: Optional[AliasCode] = Field(default=None, alias="blindingSchema")
    __properties = ["id", "name", "label", "description", "studyType", "studyPhase", "therapeuticAreas", "characteristics", "encounters", "activities", "biomedicalConcepts", "bcCategories", "bcSurrogates", "arms", "studyCells", "rationale", "epochs", "elements", "estimands", "indications", "studyInterventions", "objectives", "population", "analysisPopulations", "scheduleTimelines", "biospecimenRetentions", "documentVersionIds", "dictionaries", "conditions", "notes", "instanceType", "subTypes", "model", "intentTypes", "blindingSchema"]

    @validator('instance_type')
    def instance_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('InterventionalStudyDesign',):
            raise ValueError("must be one of enum values ('InterventionalStudyDesign')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> InterventionalStudyDesignInput:
        """Create an instance of InterventionalStudyDesignInput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of study_type
        if self.study_type:
            _dict['studyType'] = self.study_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of study_phase
        if self.study_phase:
            _dict['studyPhase'] = self.study_phase.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in therapeutic_areas (list)
        _items = []
        if self.therapeutic_areas:
            for _item in self.therapeutic_areas:
                if _item:
                    _items.append(_item.to_dict())
            _dict['therapeuticAreas'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in characteristics (list)
        _items = []
        if self.characteristics:
            for _item in self.characteristics:
                if _item:
                    _items.append(_item.to_dict())
            _dict['characteristics'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in encounters (list)
        _items = []
        if self.encounters:
            for _item in self.encounters:
                if _item:
                    _items.append(_item.to_dict())
            _dict['encounters'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in activities (list)
        _items = []
        if self.activities:
            for _item in self.activities:
                if _item:
                    _items.append(_item.to_dict())
            _dict['activities'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biomedical_concepts (list)
        _items = []
        if self.biomedical_concepts:
            for _item in self.biomedical_concepts:
                if _item:
                    _items.append(_item.to_dict())
            _dict['biomedicalConcepts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_categories (list)
        _items = []
        if self.bc_categories:
            for _item in self.bc_categories:
                if _item:
                    _items.append(_item.to_dict())
            _dict['bcCategories'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bc_surrogates (list)
        _items = []
        if self.bc_surrogates:
            for _item in self.bc_surrogates:
                if _item:
                    _items.append(_item.to_dict())
            _dict['bcSurrogates'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in arms (list)
        _items = []
        if self.arms:
            for _item in self.arms:
                if _item:
                    _items.append(_item.to_dict())
            _dict['arms'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_cells (list)
        _items = []
        if self.study_cells:
            for _item in self.study_cells:
                if _item:
                    _items.append(_item.to_dict())
            _dict['studyCells'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in epochs (list)
        _items = []
        if self.epochs:
            for _item in self.epochs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['epochs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in elements (list)
        _items = []
        if self.elements:
            for _item in self.elements:
                if _item:
                    _items.append(_item.to_dict())
            _dict['elements'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in estimands (list)
        _items = []
        if self.estimands:
            for _item in self.estimands:
                if _item:
                    _items.append(_item.to_dict())
            _dict['estimands'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in indications (list)
        _items = []
        if self.indications:
            for _item in self.indications:
                if _item:
                    _items.append(_item.to_dict())
            _dict['indications'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in study_interventions (list)
        _items = []
        if self.study_interventions:
            for _item in self.study_interventions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['studyInterventions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in objectives (list)
        _items = []
        if self.objectives:
            for _item in self.objectives:
                if _item:
                    _items.append(_item.to_dict())
            _dict['objectives'] = _items
        # override the default output from pydantic by calling `to_dict()` of population
        if self.population:
            _dict['population'] = self.population.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in analysis_populations (list)
        _items = []
        if self.analysis_populations:
            for _item in self.analysis_populations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['analysisPopulations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in schedule_timelines (list)
        _items = []
        if self.schedule_timelines:
            for _item in self.schedule_timelines:
                if _item:
                    _items.append(_item.to_dict())
            _dict['scheduleTimelines'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in biospecimen_retentions (list)
        _items = []
        if self.biospecimen_retentions:
            for _item in self.biospecimen_retentions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['biospecimenRetentions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in dictionaries (list)
        _items = []
        if self.dictionaries:
            for _item in self.dictionaries:
                if _item:
                    _items.append(_item.to_dict())
            _dict['dictionaries'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in conditions (list)
        _items = []
        if self.conditions:
            for _item in self.conditions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['conditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in notes (list)
        _items = []
        if self.notes:
            for _item in self.notes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['notes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in sub_types (list)
        _items = []
        if self.sub_types:
            for _item in self.sub_types:
                if _item:
                    _items.append(_item.to_dict())
            _dict['subTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of model
        if self.model:
            _dict['model'] = self.model.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in intent_types (list)
        _items = []
        if self.intent_types:
            for _item in self.intent_types:
                if _item:
                    _items.append(_item.to_dict())
            _dict['intentTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of blinding_schema
        if self.blinding_schema:
            _dict['blindingSchema'] = self.blinding_schema.to_dict()
        # set to None if label (nullable) is None
        # and __fields_set__ contains the field
        if self.label is None and "label" in self.__fields_set__:
            _dict['label'] = None

        # set to None if description (nullable) is None
        # and __fields_set__ contains the field
        if self.description is None and "description" in self.__fields_set__:
            _dict['description'] = None

        # set to None if study_type (nullable) is None
        # and __fields_set__ contains the field
        if self.study_type is None and "study_type" in self.__fields_set__:
            _dict['studyType'] = None

        # set to None if study_phase (nullable) is None
        # and __fields_set__ contains the field
        if self.study_phase is None and "study_phase" in self.__fields_set__:
            _dict['studyPhase'] = None

        # set to None if population (nullable) is None
        # and __fields_set__ contains the field
        if self.population is None and "population" in self.__fields_set__:
            _dict['population'] = None

        # set to None if blinding_schema (nullable) is None
        # and __fields_set__ contains the field
        if self.blinding_schema is None and "blinding_schema" in self.__fields_set__:
            _dict['blindingSchema'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> InterventionalStudyDesignInput:
        """Create an instance of InterventionalStudyDesignInput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return InterventionalStudyDesignInput.parse_obj(obj)

        _obj = InterventionalStudyDesignInput.parse_obj({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "label": obj.get("label"),
            "description": obj.get("description"),
            "study_type": Code.from_dict(obj.get("studyType")) if obj.get("studyType") is not None else None,
            "study_phase": AliasCode.from_dict(obj.get("studyPhase")) if obj.get("studyPhase") is not None else None,
            "therapeutic_areas": [Code.from_dict(_item) for _item in obj.get("therapeuticAreas")] if obj.get("therapeuticAreas") is not None else None,
            "characteristics": [Code.from_dict(_item) for _item in obj.get("characteristics")] if obj.get("characteristics") is not None else None,
            "encounters": [EncounterInput.from_dict(_item) for _item in obj.get("encounters")] if obj.get("encounters") is not None else None,
            "activities": [ActivityInput.from_dict(_item) for _item in obj.get("activities")] if obj.get("activities") is not None else None,
            "biomedical_concepts": [BiomedicalConceptInput.from_dict(_item) for _item in obj.get("biomedicalConcepts")] if obj.get("biomedicalConcepts") is not None else None,
            "bc_categories": [BiomedicalConceptCategoryInput.from_dict(_item) for _item in obj.get("bcCategories")] if obj.get("bcCategories") is not None else None,
            "bc_surrogates": [BiomedicalConceptSurrogateInput.from_dict(_item) for _item in obj.get("bcSurrogates")] if obj.get("bcSurrogates") is not None else None,
            "arms": [StudyArmInput.from_dict(_item) for _item in obj.get("arms")] if obj.get("arms") is not None else None,
            "study_cells": [StudyCell.from_dict(_item) for _item in obj.get("studyCells")] if obj.get("studyCells") is not None else None,
            "rationale": obj.get("rationale"),
            "epochs": [StudyEpochInput.from_dict(_item) for _item in obj.get("epochs")] if obj.get("epochs") is not None else None,
            "elements": [StudyElementInput.from_dict(_item) for _item in obj.get("elements")] if obj.get("elements") is not None else None,
            "estimands": [EstimandInput.from_dict(_item) for _item in obj.get("estimands")] if obj.get("estimands") is not None else None,
            "indications": [IndicationInput.from_dict(_item) for _item in obj.get("indications")] if obj.get("indications") is not None else None,
            "study_interventions": [StudyInterventionInput.from_dict(_item) for _item in obj.get("studyInterventions")] if obj.get("studyInterventions") is not None else None,
            "objectives": [ObjectiveInput.from_dict(_item) for _item in obj.get("objectives")] if obj.get("objectives") is not None else None,
            "population": StudyDesignPopulationInput.from_dict(obj.get("population")) if obj.get("population") is not None else None,
            "analysis_populations": [AnalysisPopulationInput.from_dict(_item) for _item in obj.get("analysisPopulations")] if obj.get("analysisPopulations") is not None else None,
            "schedule_timelines": [ScheduleTimelineInput.from_dict(_item) for _item in obj.get("scheduleTimelines")] if obj.get("scheduleTimelines") is not None else None,
            "biospecimen_retentions": [BiospecimenRetention.from_dict(_item) for _item in obj.get("biospecimenRetentions")] if obj.get("biospecimenRetentions") is not None else None,
            "document_version_ids": obj.get("documentVersionIds"),
            "dictionaries": [SyntaxTemplateDictionary.from_dict(_item) for _item in obj.get("dictionaries")] if obj.get("dictionaries") is not None else None,
            "conditions": [ConditionInput.from_dict(_item) for _item in obj.get("conditions")] if obj.get("conditions") is not None else None,
            "notes": [CommentAnnotation.from_dict(_item) for _item in obj.get("notes")] if obj.get("notes") is not None else None,
            "instance_type": obj.get("instanceType"),
            "sub_types": [Code.from_dict(_item) for _item in obj.get("subTypes")] if obj.get("subTypes") is not None else None,
            "model": Code.from_dict(obj.get("model")) if obj.get("model") is not None else None,
            "intent_types": [Code.from_dict(_item) for _item in obj.get("intentTypes")] if obj.get("intentTypes") is not None else None,
            "blinding_schema": AliasCode.from_dict(obj.get("blindingSchema")) if obj.get("blindingSchema") is not None else None
        })
        return _obj


